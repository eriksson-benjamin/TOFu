Shot number: 94874
Running on 16 cores.
Collecting data from LPF...
Wrote profile results to create_TOF.py.lprof
Timer unit: 1e-06 s

Total time: 0 s
File: /home/beriksso/TOFu/analysis/benjamin/github/TOFu/functions/tofu_functions.py
Function: find_threshold at line 216

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   216                                           @profile
   217                                           def find_threshold(pulse_data, trig_level, timer = False, detector_name = 'None'):
   218                                               '''
   219                                               Finds the point in the pulse which crosses the trigger level (generally 16, 17, 18 or 19 ns for ADQ14).
   220                                               Mainly relevant for ADQ14 cards since the number of pre trigger samples varies.
   221                                               pulse_data: array of pulse height data where each row corresponds to one record.
   222                                               trig_level: trigger level used during acquisition of the data set
   223                                               '''
   224                                               if timer: t_start = elapsed_time()
   225                                               # Subtract the trigger level from pulse data
   226                                               pulse_data = pulse_data - trig_level
   227                                           
   228                                               # Find all negative numbers (positive numbers correspond to elements above the threshold)
   229                                               neg_pulse_data = np.where(pulse_data <= 0)
   230                                           
   231                                               # Find the index of the first ocurrence of each number in neg_pulse_data
   232                                               # Example: neg_pulse_data[0] = [0(this one), 0, 0, 0, 0, 1(this one), 1, 1, 2(this one), 2, 2, 2...]
   233                                               u, indices = np.unique(neg_pulse_data[0], return_index = True)
   234                                           
   235                                               # Choose the corresponding elements from neg_pulse_data[1]
   236                                               thr_crossing = neg_pulse_data[1][indices]
   237                                               if timer: elapsed_time(t_start, 'find_threshold()')
   238                                           
   239                                               return thr_crossing

Total time: 0 s
File: /home/beriksso/TOFu/analysis/benjamin/github/TOFu/functions/tofu_functions.py
Function: time_pickoff_CFD at line 341

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   341                                           @profile
   342                                           def time_pickoff_CFD(pulse_data, fraction = 0.3, timer = False):
   343                                               '''
   344                                               Returns the times of arrival for a 2D array of pulses using a constant
   345                                               fraction + linear interpolation method.
   346                                               pulse_data: 2D array of pulses where each row corresponds to one pulse
   347                                               fraction: fraction at which to perform linear interpolation
   348                                               return a 1D array of times-of-arrival for each pulse.
   349                                               '''
   350                                               
   351                                               new_time = np.zeros([len(pulse_data)])
   352                                           
   353                                               # Determine whether data needs to be chunked or not
   354                                               if len(pulse_data) > 5E+5: chunk_data = True
   355                                               else: chunk_data = False
   356                                           
   357                                               if timer: t_start = elapsed_time()
   358                                               if chunk_data:
   359                                                   # Chunk array in chunks of ~5E5 rows
   360                                                   n_chunks = int(np.ceil(len(pulse_data) / 5E+5))
   361                                                   chunked_data = np.array_split(pulse_data, n_chunks, axis = 0)
   362                                                   
   363                                           
   364                                               else: chunked_data = [pulse_data]
   365                                               new_time_counter = 0
   366                                               for pulse_data in chunked_data:
   367                                                   # Find the minima and a fraction of the minima
   368                                                   minima = np.min(pulse_data, axis = 1)
   369                                                   minima_fraction = minima * fraction
   370                                                   # Find position of minimum
   371                                               #    minima_pos = np.argmin(pulse_data, axis = 1)
   372                                               #    print('Warning: ' + str(len(minima_pos[minima_pos < 100])) + ' pulses have minimum before 10 ns.')
   373                                                   
   374                                               
   375                                                   # Find the index of the point closest to the fraction of the minimum
   376                                                   # Look only in the first 25 ns (leading edge) of the pulse
   377                                                   x_closest = find_points(pulse_data[:, 0:250], minima_fraction, timer = timer)
   378                                               
   379                                               
   380                                                   # Set up for simple linear regression
   381                                                   reg_x = np.zeros([len(x_closest), 3])
   382                                                   reg_y = np.zeros([len(x_closest), 3])
   383                                                   array_1D = np.arange(0, len(pulse_data), 1)
   384                                                   
   385                                                   # Choose the three points on which to perform simple linear regression
   386                                                   reg_y[:, 0] = pulse_data[array_1D, x_closest - 1]
   387                                                   reg_y[:, 1] = pulse_data[array_1D, x_closest]
   388                                                   reg_y[:, 2] = pulse_data[array_1D, x_closest + 1]
   389                                               
   390                                                   reg_x[:, 0] = x_closest - 1
   391                                                   reg_x[:, 1] = x_closest
   392                                                   reg_x[:, 2] = x_closest + 1
   393                                                   
   394                                                   # Perform simple linear regression
   395                                                   slopes, intercepts = linear_regression(reg_x, reg_y, timer = timer)
   396                                                   # Solve the y = kx + m equation for x. y = minima_fraction
   397                                                   new_time[new_time_counter:len(pulse_data)+new_time_counter] = (minima_fraction - intercepts) / slopes
   398                                                   new_time_counter += len(pulse_data)
   399                                                   
   400                                           
   401                                               if timer: elapsed_time(t_start, 'time_pickoff_CFD()')
   402                                               return new_time

Total time: 0 s
File: /home/beriksso/TOFu/analysis/benjamin/github/TOFu/functions/tofu_functions.py
Function: sTOF4 at line 454

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   454                                           @profile
   455                                           def sTOF4(S1_times, S2_times, t_back = 100, t_forward = 100, return_indices = False, timer = False):
   456                                           
   457                                               '''
   458                                               We choose an event in S2, define the width of the window in which we want
   459                                               to search for an event in S1 and calculate the time difference between 
   460                                               the chosen S2 time stamp and the found S1 time stamp(s)
   461                                               S1_times: 1D array of time stamps for one S1
   462                                               S2_times: 1D array of time stamps for one S2
   463                                               t_back: Number of time units (usually ns) to look back in time to find coincidences between S2 and S1 (gives positive TOF's)
   464                                               t_forward: Number of time units (usually ns) to look forwards in time to find coincidences between S2 and S1 (gives negative TOF's)
   465                                               Example: coincidences = sTOF3(S1_time_stamps, S2_time_stamps, t_back = 400, t_forward = 200)
   466                                               '''
   467                                               if timer: t_start = elapsed_time()
   468                                               # Define time windows
   469                                               w_low = S2_times - t_back
   470                                               w_high = S2_times + t_forward
   471                                               
   472                                               # We will store time differences in dt
   473                                               dt = -9999 * np.ones(5 * len(S2_times))
   474                                               ind = -9999 * np.ones([5 * len(S2_times), 2])
   475                                               counter = 0
   476                                               finished = False
   477                                               
   478                                               for i in range(0, len(S2_times)):
   479                                                   
   480                                                   search_sorted = 0
   481                                                   # Find the time stamp in S1 closest to wLow (rounded up, i.e. just outside the window)
   482                                                   lowest_index = np.searchsorted(S1_times, w_low[i])
   483                                                   while True:
   484                                                       # Increase to next event
   485                                                       low_index = lowest_index + search_sorted
   486                                                       # If the time stamp is the final one in S1 we break
   487                                                       if lowest_index >= len(S1_times) - 1 or low_index >= len(S1_times): 
   488                                                           finished = True
   489                                                           break
   490                                                   
   491                                                       # If the time stamp in S1 is beyond the window we go to next S2 time (there are no more time stamps within this window)
   492                                                       if S1_times[low_index] >= w_high[i]: break
   493                                                       # If the time stamp in S1 is before the window check the next time stamp    
   494                                                       if S1_times[low_index] <= w_low[i]: 
   495                                                           search_sorted += 1
   496                                                           continue
   497                                                   
   498                                                       # If there is an event we calculate the time difference
   499                                                       dt[counter] =  S2_times[i] - S1_times[low_index]
   500                                                       # Save the S1 and S2 index of the event
   501                                                       ind[counter][0] = low_index
   502                                                       ind[counter][1] = i
   503                                                       counter += 1
   504                                                       search_sorted += 1
   505                                                   if finished: break
   506                                               
   507                                               # Find and remove all fails from dt
   508                                               dtx = dt[(dt != -9999)]
   509                                           
   510                                               ind_S1 = ind[:, 0][ind[:, 0] != -9999]
   511                                               ind_S2 = ind[:, 1][ind[:, 1] != -9999]
   512                                           
   513                                               if timer: elapsed_time(t_start, 'sTOF4()')
   514                                               if return_indices:
   515                                                   indx = np.array([ind_S1, ind_S2], dtype = 'int')
   516                                                   return dtx, indx
   517                                               else: return dtx

Total time: 0 s
File: /home/beriksso/TOFu/analysis/benjamin/github/TOFu/functions/tofu_functions.py
Function: get_pulse_area at line 603

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   603                                           @profile
   604                                           def get_pulse_area(pulses, u_factor, timer = False):
   605                                               '''
   606                                               Returns the areas under an array of pulses
   607                                               pulses: m*n array of pulses
   608                                               u_factor: frequency of samples in each pulse (u_factor = 10 -> 1/10 ns between each sample)
   609                                               '''
   610                                               
   611                                               if timer: t_start = elapsed_time()
   612                                               
   613                                               # Chunk data if too many pulses
   614                                               pulse_area = np.zeros(len(pulses))
   615                                               
   616                                               if len(pulses) > 1E+6:
   617                                                   # Chunk array in chunks of ~1E6 rows
   618                                                   n_chunks = int(np.ceil(len(pulses) / 1E+6))
   619                                                   chunked_data = np.array_split(pulses, n_chunks, axis = 0)
   620                                               
   621                                               # Otherwise use full data set at once
   622                                               else: chunked_data = [pulses]
   623                                               
   624                                               # Find area under pulse
   625                                               counter = 0
   626                                               for chunk in chunked_data:
   627                                                   pulse_area[counter:len(chunk) + counter] = np.trapz(chunk, axis = 1, dx = 1. / u_factor)
   628                                                   counter += len(chunk)
   629                                                   
   630                                               if timer: elapsed_time(t_start, 'get_pulse_area()')
   631                                               return pulse_area

